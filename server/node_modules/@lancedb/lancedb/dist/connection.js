"use strict";
// Copyright 2024 Lance Developers.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalConnection = exports.Connection = void 0;
exports.cleanseStorageOptions = cleanseStorageOptions;
const arrow_1 = require("./arrow");
const registry_1 = require("./embedding/registry");
const table_1 = require("./table");
/**
 * A LanceDB Connection that allows you to open tables and create new ones.
 *
 * Connection could be local against filesystem or remote against a server.
 *
 * A Connection is intended to be a long lived object and may hold open
 * resources such as HTTP connection pools.  This is generally fine and
 * a single connection should be shared if it is going to be used many
 * times. However, if you are finished with a connection, you may call
 * close to eagerly free these resources.  Any call to a Connection
 * method after it has been closed will result in an error.
 *
 * Closing a connection is optional.  Connections will automatically
 * be closed when they are garbage collected.
 *
 * Any created tables are independent and will continue to work even if
 * the underlying connection has been closed.
 */
class Connection {
    [Symbol.for("nodejs.util.inspect.custom")]() {
        return this.display();
    }
}
exports.Connection = Connection;
class LocalConnection extends Connection {
    inner;
    constructor(inner) {
        super();
        this.inner = inner;
    }
    isOpen() {
        return this.inner.isOpen();
    }
    close() {
        this.inner.close();
    }
    display() {
        return this.inner.display();
    }
    async tableNames(options) {
        return this.inner.tableNames(options?.startAfter, options?.limit);
    }
    async openTable(name, options) {
        const innerTable = await this.inner.openTable(name, cleanseStorageOptions(options?.storageOptions), options?.indexCacheSize);
        return new table_1.LocalTable(innerTable);
    }
    async createTable(nameOrOptions, data, options) {
        if (typeof nameOrOptions !== "string" && "name" in nameOrOptions) {
            const { name, data, ...options } = nameOrOptions;
            return this.createTable(name, data, options);
        }
        if (data === undefined) {
            throw new Error("data is required");
        }
        const { buf, mode } = await table_1.Table.parseTableData(data, options);
        let dataStorageVersion = "stable";
        if (options?.dataStorageVersion !== undefined) {
            dataStorageVersion = options.dataStorageVersion;
        }
        else if (options?.useLegacyFormat !== undefined) {
            dataStorageVersion = options.useLegacyFormat ? "legacy" : "stable";
        }
        const innerTable = await this.inner.createTable(nameOrOptions, buf, mode, cleanseStorageOptions(options?.storageOptions), dataStorageVersion, options?.enableV2ManifestPaths);
        return new table_1.LocalTable(innerTable);
    }
    async createEmptyTable(name, schema, options) {
        let mode = options?.mode ?? "create";
        const existOk = options?.existOk ?? false;
        if (mode === "create" && existOk) {
            mode = "exist_ok";
        }
        let metadata = undefined;
        if (options?.embeddingFunction !== undefined) {
            const embeddingFunction = options.embeddingFunction;
            const registry = (0, registry_1.getRegistry)();
            metadata = registry.getTableMetadata([embeddingFunction]);
        }
        let dataStorageVersion = "stable";
        if (options?.dataStorageVersion !== undefined) {
            dataStorageVersion = options.dataStorageVersion;
        }
        else if (options?.useLegacyFormat !== undefined) {
            dataStorageVersion = options.useLegacyFormat ? "legacy" : "stable";
        }
        const table = (0, arrow_1.makeEmptyTable)(schema, metadata);
        const buf = await (0, arrow_1.fromTableToBuffer)(table);
        const innerTable = await this.inner.createEmptyTable(name, buf, mode, cleanseStorageOptions(options?.storageOptions), dataStorageVersion, options?.enableV2ManifestPaths);
        return new table_1.LocalTable(innerTable);
    }
    async dropTable(name) {
        return this.inner.dropTable(name);
    }
}
exports.LocalConnection = LocalConnection;
/**
 * Takes storage options and makes all the keys snake case.
 */
function cleanseStorageOptions(options) {
    if (options === undefined) {
        return undefined;
    }
    const result = {};
    for (const [key, value] of Object.entries(options)) {
        if (value !== undefined) {
            const newKey = camelToSnakeCase(key);
            result[newKey] = value;
        }
    }
    return result;
}
/**
 * Convert a string to snake case. It might already be snake case, in which case it is
 * returned unchanged.
 */
function camelToSnakeCase(camel) {
    if (camel.includes("_")) {
        // Assume if there is at least one underscore, it is already snake case
        return camel;
    }
    if (camel.toLocaleUpperCase() === camel) {
        // Assume if the string is all uppercase, it is already snake case
        return camel;
    }
    let result = camel.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
    if (result.startsWith("_")) {
        result = result.slice(1);
    }
    return result;
}
