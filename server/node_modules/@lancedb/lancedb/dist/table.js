"use strict";
// Copyright 2024 Lance Developers.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalTable = exports.Table = void 0;
const arrow_1 = require("./arrow");
const registry_1 = require("./embedding/registry");
const merge_1 = require("./merge");
const query_1 = require("./query");
const sanitize_1 = require("./sanitize");
const util_1 = require("./util");
/**
 * A Table is a collection of Records in a LanceDB Database.
 *
 * A Table object is expected to be long lived and reused for multiple operations.
 * Table objects will cache a certain amount of index data in memory.  This cache
 * will be freed when the Table is garbage collected.  To eagerly free the cache you
 * can call the `close` method.  Once the Table is closed, it cannot be used for any
 * further operations.
 *
 * Closing a table is optional.  It not closed, it will be closed when it is garbage
 * collected.
 */
class Table {
    [Symbol.for("nodejs.util.inspect.custom")]() {
        return this.display();
    }
    static async parseTableData(data, options, streaming = false) {
        let mode = options?.mode ?? "create";
        const existOk = options?.existOk ?? false;
        if (mode === "create" && existOk) {
            mode = "exist_ok";
        }
        let table;
        if ((0, arrow_1.isArrowTable)(data)) {
            table = (0, sanitize_1.sanitizeTable)(data);
        }
        else {
            table = (0, arrow_1.makeArrowTable)(data, options);
        }
        if (streaming) {
            const buf = await (0, arrow_1.fromTableToStreamBuffer)(table, options?.embeddingFunction, options?.schema);
            return { buf, mode };
        }
        else {
            const buf = await (0, arrow_1.fromTableToBuffer)(table, options?.embeddingFunction, options?.schema);
            return { buf, mode };
        }
    }
}
exports.Table = Table;
class LocalTable extends Table {
    inner;
    constructor(inner) {
        super();
        this.inner = inner;
    }
    get name() {
        return this.inner.name;
    }
    isOpen() {
        return this.inner.isOpen();
    }
    close() {
        this.inner.close();
    }
    display() {
        return this.inner.display();
    }
    async getEmbeddingFunctions() {
        const schema = await this.schema();
        const registry = (0, registry_1.getRegistry)();
        return registry.parseFunctions(schema.metadata);
    }
    /** Get the schema of the table. */
    async schema() {
        const schemaBuf = await this.inner.schema();
        const tbl = (0, arrow_1.tableFromIPC)(schemaBuf);
        return tbl.schema;
    }
    async add(data, options) {
        const mode = options?.mode ?? "append";
        const schema = await this.schema();
        const registry = (0, registry_1.getRegistry)();
        const functions = await registry.parseFunctions(schema.metadata);
        const buffer = await (0, arrow_1.fromDataToBuffer)(data, functions.values().next().value, schema);
        await this.inner.add(buffer, mode);
    }
    async update(optsOrUpdates, options) {
        const isValues = "values" in optsOrUpdates && typeof optsOrUpdates.values !== "string";
        const isValuesSql = "valuesSql" in optsOrUpdates &&
            typeof optsOrUpdates.valuesSql !== "string";
        const isMap = (obj) => {
            return obj instanceof Map;
        };
        let predicate;
        let columns;
        switch (true) {
            case isMap(optsOrUpdates):
                columns = Array.from(optsOrUpdates.entries());
                predicate = options?.where;
                break;
            case isValues && isMap(optsOrUpdates.values):
                columns = Array.from(optsOrUpdates.values.entries()).map(([k, v]) => [
                    k,
                    (0, util_1.toSQL)(v),
                ]);
                predicate = optsOrUpdates.where;
                break;
            case isValues && !isMap(optsOrUpdates.values):
                columns = Object.entries(optsOrUpdates.values).map(([k, v]) => [
                    k,
                    (0, util_1.toSQL)(v),
                ]);
                predicate = optsOrUpdates.where;
                break;
            case isValuesSql && isMap(optsOrUpdates.valuesSql):
                columns = Array.from(optsOrUpdates.valuesSql.entries());
                predicate = optsOrUpdates.where;
                break;
            case isValuesSql && !isMap(optsOrUpdates.valuesSql):
                columns = Object.entries(optsOrUpdates.valuesSql).map(([k, v]) => [
                    k,
                    v,
                ]);
                predicate = optsOrUpdates.where;
                break;
            default:
                columns = Object.entries(optsOrUpdates);
                predicate = options?.where;
        }
        await this.inner.update(predicate, columns);
    }
    async countRows(filter) {
        return await this.inner.countRows(filter);
    }
    async delete(predicate) {
        await this.inner.delete(predicate);
    }
    async createIndex(column, options) {
        // Bit of a hack to get around the fact that TS has no package-scope.
        // biome-ignore lint/suspicious/noExplicitAny: skip
        const nativeIndex = options?.config?.inner;
        await this.inner.createIndex(nativeIndex, column, options?.replace);
    }
    query() {
        return new query_1.Query(this.inner);
    }
    search(query, queryType = "auto", ftsColumns) {
        if (typeof query !== "string") {
            if (queryType === "fts") {
                throw new Error("Cannot perform full text search on a vector query");
            }
            return this.vectorSearch(query);
        }
        // If the query is a string, we need to determine if it is a vector query or a full text search query
        if (queryType === "fts") {
            return this.query().fullTextSearch(query, {
                columns: ftsColumns,
            });
        }
        // The query type is auto or vector
        // fall back to full text search if no embedding functions are defined and the query is a string
        if (queryType === "auto" && (0, registry_1.getRegistry)().length() === 0) {
            return this.query().fullTextSearch(query, {
                columns: ftsColumns,
            });
        }
        const queryPromise = this.getEmbeddingFunctions().then(async (functions) => {
            // TODO: Support multiple embedding functions
            const embeddingFunc = functions
                .values()
                .next().value;
            if (!embeddingFunc) {
                return Promise.reject(new Error("No embedding functions are defined in the table"));
            }
            return await embeddingFunc.function.computeQueryEmbeddings(query);
        });
        return this.query().nearestTo(queryPromise);
    }
    vectorSearch(vector) {
        return this.query().nearestTo(vector);
    }
    // TODO: Support BatchUDF
    async addColumns(newColumnTransforms) {
        await this.inner.addColumns(newColumnTransforms);
    }
    async alterColumns(columnAlterations) {
        await this.inner.alterColumns(columnAlterations);
    }
    async dropColumns(columnNames) {
        await this.inner.dropColumns(columnNames);
    }
    async version() {
        return await this.inner.version();
    }
    async checkout(version) {
        await this.inner.checkout(version);
    }
    async checkoutLatest() {
        await this.inner.checkoutLatest();
    }
    async listVersions() {
        return (await this.inner.listVersions()).map((version) => ({
            version: version.version,
            timestamp: new Date(version.timestamp / 1000),
            metadata: version.metadata,
        }));
    }
    async restore() {
        await this.inner.restore();
    }
    async optimize(options) {
        let cleanupOlderThanMs;
        if (options?.cleanupOlderThan !== undefined &&
            options?.cleanupOlderThan !== null) {
            cleanupOlderThanMs =
                new Date().getTime() - options.cleanupOlderThan.getTime();
        }
        return await this.inner.optimize(cleanupOlderThanMs, options?.deleteUnverified);
    }
    async listIndices() {
        return await this.inner.listIndices();
    }
    async toArrow() {
        return await this.query().toArrow();
    }
    async indexStats(name) {
        const stats = await this.inner.indexStats(name);
        if (stats === null) {
            return undefined;
        }
        return stats;
    }
    mergeInsert(on) {
        on = Array.isArray(on) ? on : [on];
        return new merge_1.MergeInsertBuilder(this.inner.mergeInsert(on));
    }
    /**
     * Check if the table uses the new manifest path scheme.
     *
     * This function will return true if the table uses the V2 manifest
     * path scheme.
     */
    async usesV2ManifestPaths() {
        return await this.inner.usesV2ManifestPaths();
    }
    /**
     * Migrate the table to use the new manifest path scheme.
     *
     * This function will rename all V1 manifests to V2 manifest paths.
     * These paths provide more efficient opening of datasets with many versions
     * on object stores.
     *
     * This function is idempotent, and can be run multiple times without
     * changing the state of the object store.
     *
     * However, it should not be run while other concurrent operations are happening.
     * And it should also run until completion before resuming other operations.
     */
    async migrateManifestPathsV2() {
        await this.inner.migrateManifestPathsV2();
    }
}
exports.LocalTable = LocalTable;
