var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.js
var src_exports = {};
__export(src_exports, {
  default: () => expressWs
});
module.exports = __toCommonJS(src_exports);
var import_http = __toESM(require("http"));
var import_express = __toESM(require("express"));
var import_ws = __toESM(require("ws"));

// src/trailing-slash.js
function addTrailingSlash(string) {
  let suffixed = string;
  if (suffixed.charAt(suffixed.length - 1) !== "/") {
    suffixed = `${suffixed}/`;
  }
  return suffixed;
}

// src/websocket-url.js
function websocketUrl(url) {
  if (url.indexOf("?") !== -1) {
    const [baseUrl, query] = url.split("?");
    return `${addTrailingSlash(baseUrl)}.websocket?${query}`;
  }
  return `${addTrailingSlash(url)}.websocket`;
}

// src/wrap-middleware.js
function wrapMiddleware(middleware) {
  return (req, res, next) => {
    if (req.ws !== null && req.ws !== void 0) {
      req.wsHandled = true;
      try {
        middleware(req.ws, req, next);
      } catch (err) {
        next(err);
      }
    } else {
      next();
    }
  };
}

// src/add-ws-method.js
function addWsMethod(target) {
  if (target.ws === null || target.ws === void 0) {
    target.ws = function addWsRoute(route, ...middlewares) {
      const wrappedMiddlewares = middlewares.map(wrapMiddleware);
      const wsRoute = websocketUrl(route);
      this.get(...[wsRoute].concat(wrappedMiddlewares));
      return this;
    };
  }
}

// src/index.js
function expressWs(app, httpServer, options = {}) {
  let server = httpServer;
  if (server === null || server === void 0) {
    server = import_http.default.createServer(app);
    app.listen = function serverListen(...args) {
      return server.listen(...args);
    };
  }
  addWsMethod(app);
  if (!options.leaveRouterUntouched) {
    addWsMethod(import_express.default.Router);
  }
  const wsOptions = options.wsOptions || {};
  wsOptions.server = server;
  const wsServer = new import_ws.default.Server(wsOptions);
  wsServer.on("connection", (socket, request) => {
    if ("upgradeReq" in socket) {
      request = socket.upgradeReq;
    }
    request.ws = socket;
    request.wsHandled = false;
    request.url = websocketUrl(request.url);
    const dummyResponse = new import_http.default.ServerResponse(request);
    dummyResponse.writeHead = function writeHead(statusCode) {
      if (statusCode > 200) {
        dummyResponse._header = "";
        socket.close();
      }
    };
    app.handle(request, dummyResponse, () => {
      if (!request.wsHandled) {
        socket.close();
      }
    });
  });
  return {
    app,
    getWss: function getWss() {
      return wsServer;
    },
    applyTo: function applyTo(router) {
      addWsMethod(router);
    }
  };
}
